# Algorithms

## BFS

Our BFS algorithm takes a source airport ID and a destination airport ID and it returns a vector of nodes that the bfs traversed through. To do this algorithm we use the adjecency list created by the dataset: airport.dat and routes.dat. We create the adjecency list by parsing through the data creating a map of int to Airport objects and a vector of route/flight objects. Then with the created map and vector we create a map that maps to an int (Airport ID) to a vector of connected/neighboring Airport IDs, doing this by going through the vector of flights and storing and comparing the IDs. We store the connected/neighboring Airport IDs in increasing order where the begin would be the lowest value. The BFS uses adjecency list to create the traversal path, it starts creating a vector of booleans for visited nodes in the size of the highest airport id then it pushing the source node to a queue then begins a while loop until the queue is empty. In the while loop it grabs the front of the queue and checks if it's been visited if it has then it will pop if not then it will push all of it's conncected nodes/neighbors into the queue then mark it as visited on the vector of boolean then pops it out of the queue then repeats this process until the queue is empty or we find the destination node. To test this we created an instance of graph on a subset of the data: airport.dat and routes.dat called test_airport1.dat and test_routes1.dat then used the find function on all the nodes in the data subset.

## Dijkstra's Algorithm

Our Dijkstra's algorithm takes a source airport ID and a destination airport ID and it returns the shortest path between the two airports in the form of a vector of all the airports that we must go through. We decided to make the weights of all of the edges between two different airports to be equal to their geographic distance from each other. We calculated the distances using the lattitude and longitude of each airport using our calculate weights function. For Dijsktra's test cases we build a small subset of the airport graph data, and we test out the shortest path between two airports in that graph. We use specific formula to calculate distance using longitude and latitude. We are printing out the shortest path consisting the name of the airports. Our distance formula covers the case that there won't exsist a single distance that is longer than couple more paths combined. For edge cases, we are testing if two connected airport shortest path is being printed, and the right order is printed when same distance is being calculated. 

## Greedy Coloring

Our Greedy Coloring algorithm takes a graph represented as an adjacency list and returns a map that maps the id of each airport to it's respective color represented as an integer. A node's neighbor is defined as any airport such that there is a flight from the original node to that other airport. We have two tests for our Greedy Coloring algorithm: simple, and complex. Our simple test is simply a map of three nodes that all have flights to and from each other (equivilently a complete undirected graph of 3 nodes). Our algorithm is able to successfully assign a unique color to each node in our simple test. Next we have a complex test where there are many more nodes connected in a more random manner. Our greedy algorithm is also able to successfully assign correct colors to each node.

# Leading Question

We used Dijkstra's algorithm to answer our leading question of: What is the shortest path between two airports? As mentioned above, Dijkstra's takes two airports as inputs and outputs a vector of all of the airports passed through during the shortest path traversal from one input airport to the other. In our main function, the user is able to specify the two airports that he wants the shortest path between and we will output the exact flights that they need to take and the airports that they will pass through for them to execute the shortest path.